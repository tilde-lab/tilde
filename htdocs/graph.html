<!-- SVG graph renderer
based on d3.js
v211213 -->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
*{font-family:"Courier New";margin:0;padding:0;}
.edge{
    fill:none;
    stroke:#ccc;
    stroke-width:1px;
}
.edge.influences{
    stroke:#06c;
}
circle{
    fill:#fff;
    stroke:#ccc;
    stroke-width:1px;
    cursor:pointer;
}
text{
    font-size:12px;
    font-weight:bold;
    cursor:pointer;
    text-shadow:0 2px 0 #fff, 2px 0 0 #fff, 0 -2px 0 #fff, -2px 0 0 #fff;
    fill:#000;
}
text.shadow{
    stroke:#fff;
    stroke-width:3px;
    stroke-opacity:0.8;
}
</style>

<script type="text/javascript" src="/static/d3.v3.min.js"></script>
</head>
<body>
    
<div style="position:fixed;top:30px;right:0;padding:20px;width:300px;height:100px;text-align:right;line-height:1.5em;font-size:1.4em;">
    Legend:
    <div id="legend_inferred" style="display:none;" class="legends">
        <div style="color:#0c3;font-weight:bold;">node influences on<div style="float:right;width:20px;height:20px;background:#0c3;"></div></div>
        <div style="color:#f00;font-weight:bold;">node is influenced by<div style="float:right;width:20px;height:20px;background:#f00;"></div></div>
    </div>
    <div id="legend_none" style="display:none;" class="legends">
        no conclusions made
    </div>
    <div id="legend_init" style="display:none;" class="legends">
        touch any node to start
    </div>
</div>
    
<script type="text/javascript">
var build_graph;
(build_graph = function(){
    var source=[];
    var edges=[], nodes={};
    var actson={}, actedby={};
    
    if (!("_tilde" in window.parent) || !("graph_comm" in window.parent._tilde)){
        source = [{'source': 'primary', 'target': 'secondary', 'type': 'belongs' }, {'source': 'primary', 'target': 'ternary', 'type': 'influences' }, {'source': 'secondary', 'target': 'ternary', 'type': 'actson' },{'source': 'ternary', 'target': 'secondary', 'type': 'actedby' }];
    } else {    
        source = JSON.parse(window.parent._tilde.graph_comm);
    }
    
    // Filter edges and compute the distinct nodes from the links
    source.forEach(function(link){
        if (link.type == 'actson'){
            (link.source in actson) ? (actson[link.source].push(link.target)) : actson[link.source] = [link.target];
        } else if (link.type == 'actedby') {
            (link.source in actedby) ? (actedby[link.source].push(link.target)) : actedby[link.source] = [link.target];
        } else {
            link.source = nodes[link.source] || (nodes[link.source] = {name: link.source});
            link.target = nodes[link.target] || (nodes[link.target] = {name: link.target});
            edges.push(link);
        }
    });
            
    var table = {};
    var i=0;
    for (var p in nodes){
        table[p] = i++;
    }

    var width = document.body.clientWidth-100, height = 1400;
    
    d3.select("svg").remove();
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);
        
    // Per-type markers
    svg.append("defs").selectAll("marker")
        .data(["belongs", "influences"])
        .enter().append("marker")
        .attr("id", function(d){return d})
        .attr("viewBox", "0 0 40 40")
        .attr("refX", 65)
        .attr("refY", 20)
        .attr("markerWidth", 16)
        .attr("markerHeight", 12)
        .attr("orient", "auto")
        .append("polyline")
        .attr("points", "0,0 40,20 0,40 10,20").style("fill", "#ccc");

    var force = d3.layout.force()
        .nodes(d3.values(nodes))
        .links(edges)
        .size([width, height*=2/3])
        .linkDistance(130)
        .gravity(0.09)
        .charge(-400)
        .on("tick", tick)
        .start();
        
    var path = svg.append("g").selectAll("path")
        .data(force.links())
        .enter().append("path")
        .attr("class", function(d) { return "edge " + d.type; })
        .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });
        
    var link = svg.selectAll(".edge");

    var circle = svg.append("g").selectAll("circle")
        .data(force.nodes())
        .enter().append("circle")
        .attr("r", 8)
        .attr("id", function(d,i) { return "c_"+table[d.name] })
        .call(force.drag);

    var text = svg.append("g").selectAll("g")
        .data(force.nodes())
        .enter().append("g");

    // A copy of the text with a thick white stroke for legibility
    text.append("text")
        .attr("x", 12)
        .attr("y", ".31em")
        .attr("class", "shadow")
        .attr("id", function(d,i) { return "s_"+table[d.name] })
        .text(function(d) { return d.name; });

    text.append("text")
        .attr("x", 12)
        .attr("y", ".31em")
        .attr("id", function(d,i) { return "t_"+table[d.name] })
        .text(function(d) { return d.name; });
        
    circle.on("mouseover", function(d) { handle(d) });
    text.on("mouseover", function(d) { handle(d) });
    circle.on("mouseout", function(d) { dehandle(d) });
    text.on("mouseout", function(d) { dehandle(d) });

    function tick() {        
      path.attr("d", direct);
      circle.attr("transform", transform);
      text.attr("transform", transform);
    }

    function direct(d) {
      return "M" + d.source.x + "," + d.source.y + " " + d.target.x + "," + d.target.y;
    }

    function transform(d) {
      return "translate(" + d.x + "," + d.y + ")";
    }
    
    function handle(x){
        var showflag;
        if (x.name in actson){
            actson[x.name].forEach(function(v){
                d3.select('#c_' + table[v]).style("fill", "#0c3");
                d3.select('#t_' + table[v]).style("fill", "#0c3");
            });
            showflag=1
        }
        if (x.name in actedby){
            actedby[x.name].forEach(function(v){
                d3.select('#c_' + table[v]).style("fill", "#f00");
                d3.select('#t_' + table[v]).style("fill", "#f00");
            });
            showflag=1
        }
        if (showflag){
            d3.selectAll('div.legends').style("display", "none");
            d3.select('#legend_inferred').style("display", "block");    
        } else {
            d3.selectAll('div.legends').style("display", "none");
            d3.select('#legend_none').style("display", "block");    
        }
    }
    
    function dehandle(x){
        d3.selectAll('text').style("fill", "#000");
        d3.selectAll('circle').style("fill", "#fff");
        d3.selectAll('div.legends').style("display", "none");
        d3.select('#legend_init').style("display", "block");
    }  
    
    // Speed up simulation convergence
    var s=0;
    while(force.alpha() > 0.01) {
        force.tick();
        if(s++ > 500) break;
    }
    
    d3.selectAll('div.legends').style("display", "none");
    d3.select('#legend_init').style("display", "block");
})();
</script>
</body>
</html>
